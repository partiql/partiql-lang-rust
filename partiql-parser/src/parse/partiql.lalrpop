use crate::parse::lexer;
use crate::result::ParseError;

use lalrpop_util as lpop;

use lpop::ErrorRecovery;
use std::str::FromStr;

use partiql_ast::ast;
use partiql_ast::ast::ToAstNode;

use partiql_source_map::location::{ByteOffset, BytePosition, Location, ToLocated};


grammar<'input, 'err>(input: &'input str,
                      errors: &'err mut Vec<ErrorRecovery<ByteOffset, lexer::Token<'input>, ParseError<'input, BytePosition>>>);


// ------------------------------------------------------------------------------ //
//                                                                                //
//                            UNION/INTERSECT/EXCEPT                              //
//                                                                                //
// ------------------------------------------------------------------------------ //

// Note: the Set operation rules are formulated in a precise way to assure 'natural'
//    interpretation of set operations in an LR grammar while attempting
//    to stay in accordance with SQL interpretations.
//
// In particular:
//    - in order to assure operator precedence, the lowest precedence operators
//      (i.e., `UNION` & `EXCEPT`) are at the top of the recursion tree, and the highest
//      precedence are at the bottom (i.e., `INTERSECT`)
//    - all set operations are left-associative and are thus expressed as left-self-recursive rules

pub Query: Box<ast::Expr> = {
    <lo:@L>
    <set:QuerySetPrec02>
    <order_by:OrderByClause?>
    <limit:LimitClause?>
    <offset:OffsetByClause?>
    <hi:@R> => {
        Box::new(ast::Expr {
            kind: ast::ExprKind::Query(
                ast::Query { set, order_by, limit, offset, } .ast(lo..hi),
            ),
        })
    }
}

QuerySetPrec02: ast::QuerySetAst = {
    <lo:@L> <lhs:QuerySetPrec02> <setop:SetOpUnionExcept> <setq:SetQuantifier> <rhs:QuerySetPrec01> <hi:@R> => {
        ast::QuerySet::SetOp(Box::new(ast::SetExpr { setop, setq, lhs: Box::new(lhs), rhs: Box::new(rhs)}.ast(lo..hi))).ast(lo..hi)
	},
    <QuerySetPrec01>
}

QuerySetPrec01: ast::QuerySetAst = {
    <lo:@L> <lhs:QuerySetPrec01> <setop:SetOpIntersect> <setq:SetQuantifier> <rhs:SingleQuery> <hi:@R> => {
        ast::QuerySet::SetOp(Box::new(ast::SetExpr { setop, setq, lhs: Box::new(lhs), rhs: Box::new(rhs)}.ast(lo..hi))).ast(lo..hi)
	},
    <SingleQuery>
}

#[inline]
SetOpUnionExcept: ast::SetOperator = {
    "UNION" => ast::SetOperator::Union,
    "EXCEPT" => ast::SetOperator::Except,
}

#[inline]
SetOpIntersect: ast::SetOperator = {
    "INTERSECT" => ast::SetOperator::Intersect
}

#[inline]
SetQuantifier: ast::SetQuantifier = {
    "DISTINCT" => ast::SetQuantifier::Distinct,
    "ALL"? => ast::SetQuantifier::All,
}

// ------------------------------------------------------------------------------ //
//                                                                                //
//                            ExprQuery or SFW Query                              //
//                                                                                //
// ------------------------------------------------------------------------------ //
SingleQuery: ast::QuerySetAst = {
    <lo:@L> <expr:ExprQuery> <hi:@R> => {
        match *expr {
           ast::Expr{ kind: ast::ExprKind::Query(ast::QueryAst{ node: ast::Query{set, order_by:None, limit:None, offset:None} , .. })} => set,
           _ => ast::QuerySet::Expr( expr ).ast(lo..hi),
        }
    },
    <lo:@L> <sfw:SfwQuery> <hi:@R> => ast::QuerySet::Select( Box::new(sfw) ).ast(lo..hi),
    <lo:@L> <values:Values> <hi:@R> => values,
}

Values: ast::QuerySetAst = {
    <lo:@L> "VALUES" <rows:CommaSepPlus<ValueRow>> <hi:@R> => ast::QuerySet::Values( rows ).ast(lo..hi)
}

#[inline]
ValueRow: Box<ast::Expr> = {
    <array:ExprTermArrayParens> => Box::new(array)
}

// ------------------------------------------------------------------------------ //
//                                                                                //
//                                   SFW Query                                    //
//                                                                                //
// ------------------------------------------------------------------------------ //
SfwQuery: ast::SelectAst = {
    <SfwClauses>,
    <FwsClauses>
}

// SQL-style where `Select` precedes `From`
SfwClauses: ast::SelectAst = {
    <lo:@L>
    <with:WithClause?>
    <project:SelectClause>
    <from:FromClause?>
    <where_clause:WhereClause?>
    <group_by:GroupClause?>
    <having:HavingClause?>
    <hi:@R> => {
        ast::Select {
            project,
            from,
            from_let: None,
            where_clause,
            group_by,
            having,
        }.ast(lo..hi)
    }
}

// PartiQL-style where `Select` is last
FwsClauses: ast::SelectAst = {
    <lo:@L>
    <with:WithClause?>
    <from:FromClause>
    <where_clause:WhereClause?>
    <group_by:GroupClause?>
    <having:HavingClause?>
    <project:SelectClause>
    <hi:@R> => {
        ast::Select {
            project,
            from: Some(from),
            from_let: None,
            where_clause,
            group_by,
            having,
        }.ast(lo..hi)
    }
}

// ------------------------------------------------------------------------------ //
//                                     WITH                                       //
// ------------------------------------------------------------------------------ //
// TODO
WithClause: () = {}

// ------------------------------------------------------------------------------ //
//                                    SELECT                                      //
// ------------------------------------------------------------------------------ //
SelectClause: ast::ProjectionAst = {
    <lo:@L> "SELECT" <strategy: SetQuantifierStrategy> "*" <hi:@R> => ast::Projection {
        kind: ast::ProjectionKind::ProjectStar,
        setq: Some(strategy)
    }.ast(lo..hi),
    <lo:@L> "SELECT" <strategy: SetQuantifierStrategy> <project_items:CommaSepPlus<Projection>> <hi:@R> => ast::Projection {
        kind: ast::ProjectionKind::ProjectList(project_items),
        setq: Some(strategy),
    }.ast(lo..hi),
    <lo:@L> "SELECT" <strategy: SetQuantifierStrategy> "VALUE" <value:ExprQuery> <hi:@R> => ast::Projection {
        kind: ast::ProjectionKind::ProjectValue(value),
        setq: Some(strategy),
    }.ast(lo..hi),
    <lo:@L> "PIVOT" <value:ExprQuery> "AT" <key:ExprQuery> <hi:@R> => ast::Projection {
        kind: ast::ProjectionKind::ProjectPivot { key, value },
        setq: None
    }.ast(lo..hi),
}

#[inline]
SetQuantifierStrategy: ast::SetQuantifier = {
    "ALL" => ast::SetQuantifier::All,
    <distinct: "DISTINCT"?> => {
        match distinct {
            Some(_) => ast::SetQuantifier::Distinct,
            None => ast::SetQuantifier::All,
        }
    }
}

#[inline]
Projection: ast::ProjectItemAst = {
    <lo:@L> <expr:ExprQuery> <hi:@R>
        => ast::ProjectItem::ProjectExpr( ast::ProjectExpr{ expr, as_alias: None } ).ast(lo..hi),
    <lo:@L> <expr:ExprQuery> "AS"? <as_alias:SymbolPrimitive> <hi:@R> => {
        ast::ProjectItem::ProjectExpr( ast::ProjectExpr{ expr, as_alias: Some(as_alias) } ).ast(lo..hi)
    },
}

// ------------------------------------------------------------------------------ //
//                                     FROM                                       //
// ------------------------------------------------------------------------------ //
FromClause: ast::FromClauseAst = {
    <lo:@L> "FROM" <mut froms:(<TableReference> "," "LATERAL"?)*> <last:TableReference> <hi:@R> => {
        let total: Location<BytePosition> = Location::from(lo.into()..hi.into());

        // use `reduce` to process the comma-seperated `TableReference`s
        //   as left-associative `CROSS JOIN`s
        froms.push(last);
        froms.into_iter()
            .reduce(|lfrom, rfrom| {
	            let start = lfrom.location.as_ref().unwrap_or(&total).start.0.clone();
                let end = rfrom.location.as_ref().unwrap_or(&total).end.0.clone();
                let range = start..end;
                let join = ast::Join {
                    kind: ast::JoinKind::Cross,
                    left: Box::new(lfrom),
                    right: Box::new(rfrom),
                    predicate: None
                };
                ast::FromClause::Join( join.ast(range.clone()) ).ast(range)
            })
            .unwrap() // safe, because we know there's at least 1 input
    }
}

TableReference: ast::FromClauseAst = {
    <TableNonJoin>,
    <TableJoined>,
}

TableNonJoin: ast::FromClauseAst = {
    <lo:@L> <t:TableBaseReference> <hi:@R> => ast::FromClause::FromLet( t ).ast(lo..hi),
    <lo:@L> <t:TableUnpivot> <hi:@R> => ast::FromClause::FromLet( t ).ast(lo..hi),
}

#[inline]
TableBaseReference: ast::FromLetAst = {
    <lo:@L> <e:ExprQuery> <hi:@R> => {
        ast::FromLet {
            expr: e,
            kind: ast::FromLetKind::Scan,
            as_alias: None,
            at_alias: None,
            by_alias: None
        }.ast(lo..hi)
    },
    <lo:@L> <e:ExprQuery> "AS"? <as_alias:SymbolPrimitive> <hi:@R> => {
        ast::FromLet {
            expr: e,
            kind: ast::FromLetKind::Scan,
            as_alias: Some(as_alias),
            at_alias: None,
            by_alias: None
        }.ast(lo..hi)
    }
}

#[inline]
TableUnpivot: ast::FromLetAst = {
    <lo:@L> "UNPIVOT" <e:ExprQuery> "AS"? <ident_as:SymbolPrimitive> "AT" <ident_at:SymbolPrimitive> <hi:@R> => {
        ast::FromLet {
            expr: e,
            kind: ast::FromLetKind::Unpivot,
            as_alias: Some(ident_as),
            at_alias: Some(ident_at),
            by_alias: None,
        }.ast(lo..hi)
    }
}

TableJoined: ast::FromClauseAst = {
    <TableCrossJoin>,
    <TableQualifiedJoin>,
    "(" <TableJoined> ")",
}

#[inline]
TableCrossJoin: ast::FromClauseAst = {
    // Note the `TableReference` on the lhs and the `TableNonJoin` on the rhs of the `JOIN`.
    // This is to prevent ambiguity in the grammar and effectively treats `JOIN` like
    //    a left-associative operator
    <lo:@L> <ltable:TableReference> "CROSS" "JOIN" <rtable:TableNonJoin> <hi:@R> => {
        let join = ast::Join {
            kind: ast::JoinKind::Cross,
            left: Box::new(ltable),
            right: Box::new(rtable),
            predicate: None
        };
        ast::FromClause::Join( join.ast(lo..hi) ).ast(lo..hi)
    }
}

#[inline]
TableQualifiedJoin: ast::FromClauseAst = {
    // Note the `TableReference` on the lhs and the `TableNonJoin` on the rhs of the `JOIN`.
    // This is to prevent ambiguity in the grammar and effectively treats `JOIN` like
    //    a left-associative operator
    <lo:@L> <ltable:TableReference> <j:JoinType> "JOIN" "LATERAL"? <rtable:TableNonJoin> <on:JoinSpec> <hi:@R> => {
        let join = ast::Join {
            kind: j,
            left: Box::new(ltable),
            right: Box::new(rtable),
            predicate: Some(on),
        };
        ast::FromClause::Join( join.ast(lo..hi) ).ast(lo..hi)
    },
    // Note the `TableReference` on the lhs and the `TableNonJoin` on the rhs of the `JOIN`.
    // This is to prevent ambiguity in the grammar and effectively treats `JOIN` like
    //    a left-associative operator
    <lo:@L> <ltable:TableReference> <spec:JoinSpecNatural> <j:JoinType> "JOIN" "LATERAL"? <rtable:TableNonJoin> <hi:@R> => {
        let join = ast::Join {
            kind: j,
            left: Box::new(ltable),
            right: Box::new(rtable),
            predicate: Some(spec)
        };
        ast::FromClause::Join( join.ast(lo..hi) ).ast(lo..hi)
    }
}
#[inline]
JoinSpecNatural: ast::JoinSpecAst = {
    <lo:@L> "NATURAL" <hi:@R> => ast::JoinSpec::Natural.ast(lo..hi)
}
#[inline]
JoinType: ast::JoinKind = {
    "INNER" => ast::JoinKind::Inner,
    "LEFT" "OUTER"? => ast::JoinKind::Left,
    "RIGHT" "OUTER"? => ast::JoinKind::Right,
    "FULL" "OUTER"? => ast::JoinKind::Full,
}
#[inline]
JoinSpec: ast::JoinSpecAst = {
    <lo:@L> "ON" <e:ExprQuery> <hi:@R> => ast::JoinSpec::On(e).ast(lo..hi),
    <lo:@L> "USING" "(" <paths:CommaSepPlus<PathExpr>> ")" <hi:@R> => ast::JoinSpec::Using( paths ).ast(lo..hi),
}

// ------------------------------------------------------------------------------ //
//                                     WHERE                                      //
// ------------------------------------------------------------------------------ //
WhereClause: Box<ast::Expr> = { "WHERE" <ExprQuery> }

// ------------------------------------------------------------------------------ //
//                                   GROUP BY                                     //
// ------------------------------------------------------------------------------ //
GroupClause: Box<ast::GroupByExprAst> = {
    <lo:@L> "GROUP" <strategy: GroupStrategy> "BY" <keys:CommaSepPlus<GroupKey>> <group_as_alias:GroupAlias?> <hi:@R> => {
        Box::new(ast::GroupByExpr{
            strategy,
            key_list: ast::GroupKeyList{ keys },
            group_as_alias,
        }.ast(lo..hi))
    }
}
#[inline]
GroupStrategy: ast::GroupingStrategy = {
    "ALL" => ast::GroupingStrategy::GroupFull,
    <partial:"PARTIAL"?> => {
        match partial {
            Some(_) => ast::GroupingStrategy::GroupPartial,
            None => ast::GroupingStrategy::GroupFull,
        }
    }
}
#[inline]
GroupKey: ast::GroupKeyAst = {
    <lo:@L> <expr:ExprQuery> <hi:@R>
        => ast::GroupKey{ expr, as_alias: None }.ast(lo..hi),
    <lo:@L> <expr:ExprQuery> "AS" <as_alias:SymbolPrimitive> <hi:@R>
        => ast::GroupKey{ expr, as_alias: Some(as_alias) }.ast(lo..hi),
}
#[inline]
GroupAlias: ast::SymbolPrimitive = {
    "GROUP" "AS" <SymbolPrimitive>
}

// ------------------------------------------------------------------------------ //
//                                    HAVING                                      //
// ------------------------------------------------------------------------------ //
HavingClause: Box<ast::Expr> = { "HAVING" <ExprQuery> }

// ------------------------------------------------------------------------------ //
//                                   ORDER BY                                     //
// ------------------------------------------------------------------------------ //
OrderByClause: Box<ast::OrderByExprAst> = {
    <lo:@L> "ORDER" "BY" "PRESERVE" <hi:@R> => Box::new( ast::OrderByExpr{ sort_specs: vec![] }.ast(lo..hi) ),
    <lo:@L> "ORDER" "BY" <sort_specs: CommaSepPlus<OrderSortSpec>> <hi:@R> => Box::new( ast::OrderByExpr{ sort_specs }.ast(lo..hi) ),
}
#[inline]
OrderSortSpec: ast::SortSpecAst = {
    <lo:@L> <expr:ExprQuery> <ordering_spec:BySpec?> <null_ordering_spec:ByNullSpec?> <hi:@R>
        => ast::SortSpec { expr, ordering_spec, null_ordering_spec }.ast(lo..hi)
}
#[inline]
BySpec: ast::OrderingSpec = {
    "ASC" => ast::OrderingSpec::Asc,
    "DESC" => ast::OrderingSpec::Desc,
}
#[inline]
ByNullSpec: ast::NullOrderingSpec = {
    "NULLS" "FIRST" => ast::NullOrderingSpec::First,
    "NULLS" "LAST" => ast::NullOrderingSpec::Last,
}

// ------------------------------------------------------------------------------ //
//                                     LIMIT                                      //
// ------------------------------------------------------------------------------ //
LimitClause: Box<ast::Expr> = { "LIMIT" <ExprQuery> }

// ------------------------------------------------------------------------------ //
//                                     OFFSET                                     //
// ------------------------------------------------------------------------------ //
OffsetByClause: Box<ast::Expr> = { "OFFSET" <ExprQuery> }

// ------------------------------------------------------------------------------ //
//                                                                                //
//                                   Expr Query                                   //
//                                                                                //
// ------------------------------------------------------------------------------ //

// Note: the `Expr` rules are formulated in a precise way to assure 'natural'
//    interpretation of mathematical expressions in an LR grammar while attempting
//    to stay in accordance with SQL interpretations.
//
// In particular:
//    - in order to assure operator precedence, the lowest precedence operators
//      (i.e., `OR`) are at the top of the recursion tree, and the highest
//      precedence are at the bottom (i.e., `<PathExpr>`)
//    - left-associative operators (i.e., '+', '-', '*', '/') are expressed as
//      left-self-recursive rules, while right-associative operators
//      (i.e., unary '-', '^) are expressed as right-self-recursive rules
//
// In the parsing tutorials and academic literature, you will often see the above
//     structure in the 'classical expression grammar':
//                 Expr -> Expr '+' Factor | Expr '-' Factor | Factor
//                 Factor -> Factor '*' Term | Factor '/' Term | Term
//                 Term -> number
//
// Instead of trying to come up with other synonyms to Expr/Factor/Term, the rules
//      here are named directly for their numeric level in the precedence table
//      in the form ExprPrecedence<NN>
//
// PartiQL's precedence levels:
// |-------+-------------------+---------------+------------------------------------|
// | Level | Operator          | Associativity | Description                        |
// |-------+-------------------+---------------+------------------------------------|
// |     1 | <Path Expression> | left          | e.g., `field`,  `binding.field[2]` |
// |     2 | <Function call>   | left          | e.g., `upper(field_reference)`     |
// |     3 | + -               | right         | unary plus, unary minus            |
// |     4 | ^                 | left          | exponentiation                     |
// |     5 | * / %             | left          | multiplication, division, modulo   |
// |     6 | + -               | left          | addition, subtraction              |
// |     7 | <other>           | left          | other operators, e.g., `||`
// |     8 | BETWEEN IN LIKE   |               | range/set/pattern compare          |
// |     9 | < > <= >=         |               | comparison operators               |
// |    10 | = <> !=           |               | equality operators                 |
// |    11 | IS                |               | IS [NOT] NULL                      |
// |    12 | NOT               | right         | logical negate                     |
// |    13 | AND               | left          | logical conjuct                    |
// |    14 | OR                | left          | logical disjunct                   |
// |-------+-------------------+---------------+------------------------------------|
//
// See https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages
// See https://en.wikipedia.org/wiki/Order_of_operations#Special_cases


ExprQuery: Box<ast::Expr> = {
    <e:ExprPrecedence15> => Box::new(e)
}

ExprPrecedence15: ast::Expr = {
    <lo:@L> <l:ExprPrecedence15> "OR" <r:ExprPrecedence14> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Or,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence14>,
}

ExprPrecedence14: ast::Expr = {
    <lo:@L> <l:ExprPrecedence14> "AND" <r:ExprPrecedence13> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::And,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence13>,
}

ExprPrecedence13: ast::Expr = {
    <lo:@L> "NOT" <r:ExprPrecedence13> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Not,
               expr: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence12>,
}

ExprPrecedence12: ast::Expr = {
    <lo:@L> <l:ExprPrecedence12> "IS" <r:ExprPrecedence11> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Is,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence12> "IS" "NOT" <r:ExprPrecedence11> <hi:@R> => {
       let is =  ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Is,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )};
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Not,
               expr: Box::new(is),
           }.ast(lo..hi)
       )}
    },
    <ExprPrecedence11>
}

ExprPrecedence11: ast::Expr = {
    <lo:@L> <l:ExprPrecedence11> "=" <r:ExprPrecedence10> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Eq,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence11> "!=" <r:ExprPrecedence10> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Ne,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence11> "<>" <r:ExprPrecedence10> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Ne,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence10>,
}

ExprPrecedence10: ast::Expr = {
    <lo:@L> <l:ExprPrecedence09> "<" <r:ExprPrecedence09> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Lt,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence09> ">" <r:ExprPrecedence09> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Gt,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence09> "<=" <r:ExprPrecedence09> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Lte,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence09> ">=" <r:ExprPrecedence09> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Gte,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence09>,
}

ExprPrecedence09: ast::Expr = {
    <lo:@L> <value:ExprPrecedence09> "BETWEEN" <from:ExprPrecedence08> "AND" <to:ExprPrecedence08> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::Between( ast::Between{ value: Box::new(value), from: Box::new(from), to: Box::new(to) }.ast(lo..hi) ) },
    <lo:@L> <value:ExprPrecedence09> "NOT" "BETWEEN" <from:ExprPrecedence08> "AND" <to:ExprPrecedence08> <hi:@R> => {
       let between = ast::Expr{ kind: ast::ExprKind::Between( ast::Between{ value: Box::new(value), from: Box::new(from), to: Box::new(to) }.ast(lo..hi) ) };
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Not,
               expr: Box::new(between),
           }.ast(lo..hi)
       )}
    },
    <lo:@L> <value:ExprPrecedence09> "LIKE" <pattern:ExprPrecedence08> <escape:LikeEscape?> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::Like( ast::Like{ value: Box::new(value), pattern: Box::new(pattern), escape }.ast(lo..hi) ) },
    <lo:@L> <value:ExprPrecedence09> "NOT" "LIKE" <pattern:ExprPrecedence08> <escape:LikeEscape?> <hi:@R>  => {
       let like = ast::Expr{ kind: ast::ExprKind::Like( ast::Like{ value: Box::new(value), pattern: Box::new(pattern), escape }.ast(lo..hi) ) };
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Not,
               expr: Box::new(like),
           }.ast(lo..hi)
       )}
    },
    <lo:@L> <l:ExprPrecedence09> "IN" <r:ExprPrecedence08> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::In( ast::In{ operands: vec![Box::new(l),Box::new(r)] }.ast(lo..hi) ) },
    <lo:@L> <l:ExprPrecedence09> "NOT" "IN" <r:ExprPrecedence08> <hi:@R> => {
       let in_expr = ast::Expr{ kind: ast::ExprKind::In( ast::In{ operands: vec![Box::new(l),Box::new(r)] }.ast(lo..hi) ) };
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Not,
               expr: Box::new(in_expr),
           }.ast(lo..hi)
       )}
    },
    <ExprPrecedence08>,
}
#[inline]
LikeEscape: Box<ast::Expr> = {
    "ESCAPE" <e:ExprPrecedence07> => Box::new(e)
}

ExprPrecedence08: ast::Expr = {
    <lo:@L> <l:ExprPrecedence08> "||" <r:ExprPrecedence07> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Concat,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence07>,
}

ExprPrecedence07: ast::Expr = {
    <lo:@L> <l:ExprPrecedence07> "+" <r:ExprPrecedence06> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Add,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence07> "-" <r:ExprPrecedence06> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Neg,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence06>,
}

ExprPrecedence06: ast::Expr = {
    <lo:@L> <l:ExprPrecedence06> "*" <r:ExprPrecedence05> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Mul,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence06> "/" <r:ExprPrecedence05> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Div,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> <l:ExprPrecedence06> "%" <r:ExprPrecedence05> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Mod,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence05>,
}

ExprPrecedence05: ast::Expr = {
    <lo:@L> <l:ExprPrecedence05> "^" <r:ExprPrecedence04> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::BinOp(
           ast::BinOp {
               kind: ast::BinOpKind::Exp,
               lhs: Box::new(l),
               rhs: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence04>,
}

ExprPrecedence04: ast::Expr = {
    <lo:@L> "+" <r:ExprPrecedence04> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Pos,
               expr: Box::new(r),
           }.ast(lo..hi)
       )},
    <lo:@L> "-" <r:ExprPrecedence04> <hi:@R> =>
       ast::Expr{ kind: ast::ExprKind::UniOp(
           ast::UniOp {
               kind: ast::UniOpKind::Neg,
               expr: Box::new(r),
           }.ast(lo..hi)
       )},
    <ExprPrecedence03>,
}

#[inline]
ExprPrecedence03: ast::Expr = {
    <casexpr:CaseExpr> => ast::Expr {
        kind: ast::ExprKind::Case(casexpr)
    },
    <ExprPrecedence02>,
}

PathExpr: ast::Path = {
    <l:ExprPrecedence01> "." <steps:PathSteps> => ast::Path { root:Box::new(l), steps },
    <l:ExprPrecedence01> "." "*" => ast::Path {
        root:Box::new(l), steps:vec![ast::PathStep::PathUnpivot]
     },
    <l:ExprPrecedence01> "[" "*" "]" => ast::Path {
        root:Box::new(l), steps:vec![ast::PathStep::PathWildCard]
    },
    <l:ExprPrecedence01> "[" <expr:ExprQuery> "]" => {
         let step = ast::PathStep::PathExpr(
             ast::PathExpr{
                 index: Box::new(*expr),
             });

        ast::Path {
            root:Box::new(l), steps:vec![step]
        }
    },
};

ExprPrecedence02: ast::Expr = {
     <lo:@L> <expr:PathExpr> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::Path( expr.ast(lo..hi) )
      },
    <ExprPrecedence01>,
}

#[inline]
ExprPrecedence01: ast::Expr = {
    <lo:@L> <call:FunctionCall> <hi:@R> => ast::Expr{ kind: ast::ExprKind::Call( call.ast(lo..hi) ) },
    <ExprTerm>,
};

pub ExprTerm: ast::Expr = {
    "(" <q:Query> ")" => *q,
    <lo:@L> <lit:Literal> <hi:@R> => ast::Expr{ kind: ast::ExprKind::Lit( lit.ast(lo..hi) ) },
    <VarRefExpr>,
    <ExprTermArray>,
    <ExprTermBag>,
    <ExprTermTuple>,
    ! => { errors.push(<>); ast::Expr{ kind: ast::ExprKind::Error} },
}

// ------------------------------------------------------------------------------ //
//                                                                                //
//                               Case Expression                                  //
//                                                                                //
// ------------------------------------------------------------------------------ //
// Implements parsing for CASE expressions.
//
// Searched Case Example:
// CASE WHEN titanId IS 1 THEN 2 WHEN titanId IS 2 THEN 3 ELSE 1 END
//
// Simple Case Example:
// CASE hello WHEN titanId IS NOT NULL THEN (SELECT * FROM data) ELSE 1 END
//
// The following is not allowed:
// CASE hello WHEN titanId IS NOT NULL THEN SELECT * FROM data ELSE 1 END
//
// This becaue as per SQL-92 standard THEN <result> ultimately leads to
// the following:
// <subquery> ::= <left paren> <query expression> <right paren>

CaseExpr: ast::CaseAst = {
    <lo:@L> "CASE" <expr:ExprQuery?> <cases:ExprPairWhenThen+> <elsexpr:ElseClause?> "END" <hi:@R> => {
        match expr {
            None => ast::Case {
                kind: ast::CaseKind::SearchedCase(
                    ast::SearchedCase { cases, default: elsexpr }
                )
            }.ast(lo..hi),
            Some(expr) => ast::Case {
                kind: ast::CaseKind::SimpleCase(
                    ast::SimpleCase { expr, cases, default: elsexpr }
                )
            }.ast(lo..hi)
        }
    }
};

ElseClause: Box<ast::Expr> = {
  "ELSE" <e:ExprQuery> => Box::new(*e)
};

ExprPairWhenThen: ast::ExprPair = {
    <lo:@L> "WHEN" <first:ExprQuery> "THEN" <second:ExprQuery> <hi:@R> => ast::ExprPair { first, second },
};

#[inline]
ExprTermArray: ast::Expr = {
    <ExprTermArrayBrackets>,
    <ExprTermArrayParens>
}
#[inline]
ExprTermArrayBrackets: ast::Expr = {
    <lo:@L> "[" <values:CommaTermStar<ExprQuery>> "]" <hi:@R> => ast::Expr{ kind: ast::ExprKind::List( ast::List{values}.ast(lo..hi) ) }
}
#[inline]
ExprTermArrayParens: ast::Expr = {
    <lo:@L> "(" <values:CommaTermPlus<ExprQuery>> ")" <hi:@R> => ast::Expr{ kind: ast::ExprKind::List( ast::List{values}.ast(lo..hi) ) },
}

#[inline]
ExprTermBag: ast::Expr = {
    <lo:@L> "<<" <values:CommaTermStar<ExprQuery>> ">>" <hi:@R> => ast::Expr{ kind: ast::ExprKind::Bag( ast::Bag{values}.ast(lo..hi) ) },
}

#[inline]
ExprTermTuple: ast::Expr = {
    <lo:@L> "{" <fields:CommaTermStar<ExprPair>> "}" <hi:@R> => ast::Expr{ kind: ast::ExprKind::Struct( ast::Struct{fields}.ast(lo..hi) ) }
}

ExprPair: ast::ExprPair = {
    <lo:@L> <first:ExprQuery> ":" <second:ExprQuery> <hi:@R> => ast::ExprPair{ first, second },
}

#[inline]
FunctionCall: ast::Call = {
    <func_name:"UnquotedIdent"> "(" <strategy: SetQuantifierStrategy> ")" =>
        ast::Call {
            func_name: ast::SymbolPrimitive {
                value: func_name.to_owned(),
                case: Some(ast::CaseSensitivity::CaseInsensitive)
            },
            args: Vec::new(),
            setq: Some(strategy)
        },
     <func_name:"UnquotedIdent"> "(" <strategy: SetQuantifierStrategy> "*" ")" =>
         ast::Call {
            func_name: ast::SymbolPrimitive {
                value: func_name.to_owned(),
                case: Some(ast::CaseSensitivity::CaseInsensitive)
            },
            args: Vec::new(),
            setq: Some(strategy)
         },
    <func_name:"UnquotedIdent"> "(" <strategy: SetQuantifierStrategy> <args:CommaSepPlus<ExprQuery>> ")" =>
        ast::Call {
            func_name: ast::SymbolPrimitive {
                value: func_name.to_owned(),
                case: Some(ast::CaseSensitivity::CaseInsensitive)
            },
            args,
            setq: Some(strategy)
        },
}

// ------------------------------------------------------------------------------ //
//                                                                                //
//                               Path Navigation                                  //
//                                                                                //
// ------------------------------------------------------------------------------ //
// Implementation of Path Navigation as specified by PartiQL Specification Section 4:
// https://partiql.org/assets/PartiQL-Specification.pdf
//
// Examples:
// a.b
// a.*
// a.[*]
// a[*]
// a.b.c
// "a".b
// "a"."b"
// { 'a': 1, 'b': 2 }.a
// [1, 2][1]
// foo(x, y).a
// (SELECT a from en).b
//
// See the path expression conformance tests under `partiql-tests` or parser unit-tests for more examples.
PathSteps: Vec<ast::PathStep> = {
    <path:PathSteps> "." <v:PathExprVarRef> => {
        let step = ast::PathStep::PathExpr(
            ast::PathExpr{
                index: Box::new(v),
            });

        let mut steps = path;
        steps.push(step);
        steps
        // ast::Path{ root:path.root, steps }
    },
    <lo:@L> <path:PathSteps>  "[" "*" "]" <hi:@R> => {
         let step = ast::PathStep::PathWildCard;

         let mut steps = path;
         steps.push(step);
         steps
         // ast::Path{ root:path.root, steps }
    },
    <lo:@L> <path:PathSteps>  "." "*" <hi:@R> => {
         let step = ast::PathStep::PathUnpivot;

         let mut steps = path;
         steps.push(step);
         steps
         // ast::Path{ root:path.root, steps }
    },
    // TODO Add path expression with CAST E.g. {'attr': 1, 'b':2}[CAST('at' || 'tr' AS STRING)]
    // once https://github.com/partiql/partiql-lang-rust/pull/122 is merged
    <lo:@L> <path:PathSteps> "[" <expr:ExprQuery> "]" <hi:@R> => {
        let step = ast::PathStep::PathExpr(
            ast::PathExpr{
                index: Box::new(*expr),
            });

        let mut steps = path;
        steps.push(step);
        steps
        // ast::Path{ root:path.root, steps }
    },
    <v:PathExprVarRef> => {
        let step = ast::PathStep::PathExpr(
            ast::PathExpr{
                index: Box::new(v),
            });
        let steps = vec![step];
        steps
        // ast::Path{ root: Box::new(v), steps: vec![] }
    },
}

PathExprVarRef: ast::Expr = {
    <lo:@L> <s:"String"> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::VarRef(ast::VarRef {
            name: ast::SymbolPrimitive { value: s.to_owned(), case: None },
            case: ast::CaseSensitivity::CaseInsensitive,
            qualifier: ast::ScopeQualifier::Unqualified
        }.ast(lo..hi)),
    },
    <VarRefExpr>,
}

VarRefExpr: ast::Expr = {
    <lo:@L> <ident:"UnquotedIdent"> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::VarRef(ast::VarRef {
            name: ast::SymbolPrimitive { value: ident.to_owned(), case: Some(ast::CaseSensitivity::CaseInsensitive) },
            case: ast::CaseSensitivity::CaseInsensitive,
            qualifier: ast::ScopeQualifier::Unqualified
        }.ast(lo..hi)),
    },
    <lo:@L> <ident:"QuotedIdent"> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::VarRef(ast::VarRef {
            name: ast::SymbolPrimitive { value: ident.to_owned(), case: Some(ast::CaseSensitivity::CaseSensitive) },
            case: ast::CaseSensitivity::CaseSensitive,
            qualifier: ast::ScopeQualifier::Unqualified
      }.ast(lo..hi)),
    },
    <lo:@L> <ident:"UnquotedAtIdentifier"> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::VarRef(ast::VarRef {
            name: ast::SymbolPrimitive { value: ident.to_owned(), case: Some(ast::CaseSensitivity::CaseInsensitive) },
            case: ast::CaseSensitivity::CaseInsensitive,
            qualifier: ast::ScopeQualifier::Unqualified
        }.ast(lo..hi)),
    },
    <lo:@L> <ident:"QuotedAtIdentifier"> <hi:@R> => ast::Expr {
        kind: ast::ExprKind::VarRef(ast::VarRef {
            name: ast::SymbolPrimitive { value: ident.to_owned(), case: Some(ast::CaseSensitivity::CaseSensitive) },
            case: ast::CaseSensitivity::CaseInsensitive,
            qualifier: ast::ScopeQualifier::Unqualified
        }.ast(lo..hi)),
    },
};

// ------------------------------------------------------------------------------ //
//                                                                                //
//                                Literal Values                                  //
//                                                                                //
// ------------------------------------------------------------------------------ //

pub Literal: ast::Lit = {
    <LiteralAbsent>,
    <LiteralScalar>,
    <LiteralIon>,
    // TODO other literals?
};

#[inline]
LiteralAbsent: ast::Lit = {
    "NULL" => ast::Lit::Null,
    "MISSING" => ast::Lit::Missing,
}
#[inline]
LiteralScalar: ast::Lit = {
    <LiteralString>,
    <LiteralBool>,
    <LiteralNumber>
}
#[inline]
LiteralString: ast::Lit = {
    <s:"String"> => ast::Lit::CharStringLit(s.to_owned()),
}
#[inline]
LiteralBool: ast::Lit = {
    "TRUE" => ast::Lit::BoolLit(true),
    "FALSE" => ast::Lit::BoolLit(false),
}
#[inline]
LiteralNumber: ast::Lit = {
    // TODO check bounds before parsing?

    <lo:@L> <n:"Int"> <hi:@R> =>? {
        n.parse()
	        .map(|n| ast::Lit::Int64Lit(n))
		    .map_err(|_| lpop::ParseError::User{
	     	    error: ParseError::SyntaxError(
		            "invalid literal".to_string().to_located(BytePosition::from(lo)..BytePosition::from(hi)))
	         })
    },
    <lo:@L> <r:"Real"> <hi:@R> =>? {
        rust_decimal::Decimal::from_str(r)
	        .map(|n| ast::Lit::DecimalLit(n))
		    .map_err(|_| lpop::ParseError::User{
	     	    error: ParseError::SyntaxError(
		            "invalid literal".to_string().to_located(BytePosition::from(lo)..BytePosition::from(hi)))
	         })
    },
    <lo:@L> <r:"ExpReal"> <hi:@R> =>? {
        rust_decimal::Decimal::from_scientific(r)
	        .map(|n| ast::Lit::DecimalLit(n))
		    .map_err(|_| lpop::ParseError::User{
	     	    error: ParseError::SyntaxError(
		            "invalid literal".to_string().to_located(BytePosition::from(lo)..BytePosition::from(hi)))
	         })
    },
}
#[inline]
LiteralIon: ast::Lit = {
    <ion:"Ion"> => ast::Lit::IonStringLit(ion.to_owned()),
}

// ------------------------------------------------------------------------------ //
//                                                                                //
//                                  Utilities                                     //
//                                                                                //
// ------------------------------------------------------------------------------ //

// Comma as terminator (i.e. "<T>, <T>, <T>," where final comma is optional); may be empty
// This is a macro; see http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
CommaTermStar<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Comma as terminator (i.e. "<T>, <T>, <T>," where final comma is optional); at least 1 arg
// This is a macro; see http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
CommaTermPlus<T>: Vec<T> = {
    <mut v:(<T> ",")+> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Comma as separator (i.e. "<T>, <T>, <T>"); may be empty
// This is a macro; see http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
CommaSepStar<T>: Vec<T> = {
    <e:T?> <mut v:("," <T>)*> => match e {
         None => vec![],
         Some(e) => {
             v.insert(0,e);
             v
        }
    }
};

// Comma as separator (i.e. "<T>, <T>, <T>"); at least 1 arg
// This is a macro; see http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
CommaSepPlus<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

SymbolPrimitive: ast::SymbolPrimitive = {
    <ident:"UnquotedIdent"> => ast::SymbolPrimitive {
        value: ident.to_owned(),
        case: Some(ast::CaseSensitivity::CaseInsensitive),
    },
    <ident:"QuotedIdent"> => ast::SymbolPrimitive {
        value: ident.to_owned(),
        case: Some(ast::CaseSensitivity::CaseSensitive),
    },
};

// ------------------------------------------------------------------------------ //
//                                                                                //
//                                    Lexer                                       //
//                                                                                //
// ------------------------------------------------------------------------------ //

// The lexer is external; See [`lexer.rs`] for its definition.
//
// See also http://lalrpop.github.io/lalrpop/lexer_tutorial/002_writing_custom_lexer.html
extern {
    type Location = ByteOffset;
    type Error = ParseError<'input, BytePosition>;

    enum lexer::Token<'input> {

        // Brackets
        "[" => lexer::Token::OpenSquare,
        "]" => lexer::Token::CloseSquare,
        "{" => lexer::Token::OpenCurly,
        "}" => lexer::Token::CloseCurly,
        "(" => lexer::Token::OpenParen,
        ")" => lexer::Token::CloseParen,
        "<<" => lexer::Token::OpenDblAngle,
        ">>" => lexer::Token::CloseDblAngle,

        // Punc
        "," => lexer::Token::Comma,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "." => lexer::Token::Period,
        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "*" => lexer::Token::Star,
        "/" => lexer::Token::Slash,
        "%" => lexer::Token::Percent,
        "^" => lexer::Token::Caret,
        "||" => lexer::Token::DblPipe,

        "=" => lexer::Token::Equal,
        "==" => lexer::Token::EqualEqual,
        "!=" => lexer::Token::BangEqual,
        "<>" => lexer::Token::LessGreater,

        "<" => lexer::Token::LessThan,
        ">" => lexer::Token::GreaterThan,
        "<=" => lexer::Token::LessEqual,
        ">=" => lexer::Token::GreaterEqual,


        // Types
        "UnquotedIdent" => lexer::Token::UnquotedIdent(<&'input str>),
        "QuotedIdent" => lexer::Token::QuotedIdent(<&'input str>),
        "UnquotedAtIdentifier" => lexer::Token::UnquotedAtIdentifier(<&'input str>),
        "QuotedAtIdentifier" => lexer::Token::QuotedAtIdentifier(<&'input str>),
        "Int" => lexer::Token::Int(<&'input str>),
        "Real" => lexer::Token::Real(<&'input str>),
        "ExpReal" => lexer::Token::ExpReal(<&'input str>),
        "String" => lexer::Token::String(<&'input str>),
        "Ion" => lexer::Token::Ion(<&'input str>),

        // Keywords
        "ALL" => lexer::Token::All,
        "ASC" => lexer::Token::Asc,
        "AND" => lexer::Token::And,
        "AS" => lexer::Token::As,
        "AT" => lexer::Token::At,
        "BETWEEN" => lexer::Token::Between,
        "BY" => lexer::Token::By,
        "CASE" => lexer::Token::Case,
        "CROSS" => lexer::Token::Cross,
        "DESC" => lexer::Token::Desc,
        "DISTINCT" => lexer::Token::Distinct,
        "ELSE" => lexer::Token::Else,
        "END" => lexer::Token::End,
        "ESCAPE" => lexer::Token::Escape,
        "EXCEPT" => lexer::Token::Except,
        "FALSE" => lexer::Token::False,
        "FIRST" => lexer::Token::First,
        "FULL" => lexer::Token::Full,
        "FROM" => lexer::Token::From,
        "GROUP" => lexer::Token::Group,
        "HAVING" => lexer::Token::Having,
        "IN" => lexer::Token::In,
        "INNER" => lexer::Token::Inner,
        "INTERSECT" => lexer::Token::Intersect,
        "IS" => lexer::Token::Is,
        "JOIN" => lexer::Token::Join,
        "LAST" => lexer::Token::Last,
        "LATERAL" => lexer::Token::Lateral,
        "LEFT" => lexer::Token::Left,
        "LIKE" => lexer::Token::Like,
        "LIMIT" => lexer::Token::Limit,
        "MISSING" => lexer::Token::Missing,
        "NATURAL" => lexer::Token::Natural,
        "NOT" => lexer::Token::Not,
        "NULL" => lexer::Token::Null,
        "NULLS" => lexer::Token::Nulls,
        "OFFSET" => lexer::Token::Offset,
        "ON" => lexer::Token::On,
        "OR" => lexer::Token::Or,
        "ORDER" => lexer::Token::Order,
        "OUTER" => lexer::Token::Outer,
        "PARTIAL" => lexer::Token::Partial,
        "PIVOT" => lexer::Token::Pivot,
        "PRESERVE" => lexer::Token::Preserve,
        "RIGHT" => lexer::Token::Right,
        "SELECT" => lexer::Token::Select,
        "THEN" => lexer::Token::Then,
        "TRUE" => lexer::Token::True,
        "UNION" => lexer::Token::Union,
        "UNPIVOT" => lexer::Token::Unpivot,
        "USING" => lexer::Token::Using,
        "VALUE" => lexer::Token::Value,
        "VALUES" => lexer::Token::Values,
        "WHEN" => lexer::Token::When,
        "WHERE" => lexer::Token::Where,
        "WITH" => lexer::Token::With,
    }
}