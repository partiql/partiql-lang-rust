use crate::generator::{TestComponent, TestModule};
use crate::util::Escaper;

use codegen::{Module, Scope};
use miette::{IntoDiagnostic, Report};

use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

const FILE_HEADER: &str = "\
// ********************************************************************************************** //
//  *NOTE*: This file is generated by partiql-conformance-test-generator. Do not edit directly.
// ********************************************************************************************** //


";

#[derive(Debug)]
#[allow(dead_code)]
pub enum TreeDepth {
    Full,
    N(u8),
}

impl TreeDepth {
    pub fn is_exceeded(&self, depth: &u8) -> bool {
        match self {
            TreeDepth::Full => false,
            TreeDepth::N(n) => depth >= n,
        }
    }
}

#[derive(Debug)]
pub struct WriterConfig {
    depth: TreeDepth,
}

impl WriterConfig {
    pub fn new(depth: TreeDepth) -> WriterConfig {
        WriterConfig { depth }
    }
}

#[derive(Debug)]
pub struct Writer {
    config: WriterConfig,
}

impl Writer {
    pub fn new(config: WriterConfig) -> Writer {
        Self { config }
    }

    pub fn write(&self, path: impl AsRef<Path>, root: TestModule) -> miette::Result<()> {
        let path: PathBuf = path
            .as_ref()
            .components()
            .map(|c| c.as_os_str().to_string_lossy().to_string().escape_path())
            .collect();
        std::fs::create_dir_all(&path).into_diagnostic()?;

        self.write_module(&path, root, 1)?;

        Ok(())
    }

    fn write_module(
        &self,
        path: impl AsRef<Path>,
        module: TestModule,
        depth: u8,
    ) -> miette::Result<()> {
        if self.config.depth.is_exceeded(&depth) {
            self.write_collapsed_module(&path, module)
        } else {
            self.write_nested_module(&path, module, depth)
        }
    }

    fn write_nested_module(
        &self,
        path: &impl AsRef<Path>,
        module: TestModule,
        depth: u8,
    ) -> Result<(), Report> {
        write_dir_mod(&path, module.children.keys())?;

        for (name, child) in module.children {
            let mut child_path: PathBuf = path.as_ref().into();
            child_path.push(&name);
            match child {
                TestComponent::Scope(mut s) => write_scope(child_path, s.module.scope())?,
                TestComponent::Module(m) => self.write_module(child_path, m, depth + 1)?,
            }
        }
        Ok(())
    }

    fn write_collapsed_module(
        &self,
        path: impl AsRef<Path>,
        module: TestModule,
    ) -> miette::Result<()> {
        let name = path.as_ref().file_name().unwrap().to_str().unwrap();
        let mut module = collapse_module(name, module)?;

        let path = PathBuf::from(path.as_ref()).with_extension("rs");
        write_scope(path, module.scope())
    }
}

fn collapse_module(name: &str, module: TestModule) -> miette::Result<Module> {
    let children = module
        .children
        .into_iter()
        .map(|(name, child)| match child {
            TestComponent::Scope(scope) => Ok(scope.module),
            TestComponent::Module(module) => collapse_module(&name, module),
        });

    let mut module = Module::new(name);
    for child in children {
        module.push_module(child?);
    }
    Ok(module)
}

fn write_dir_mod<'a>(
    path: impl AsRef<Path>,
    sub_mods: impl Iterator<Item = &'a String>,
) -> miette::Result<()> {
    std::fs::create_dir_all(&path).into_diagnostic()?;

    let mut contents = FILE_HEADER.to_string();
    for sub_mod in sub_mods {
        contents.push_str(&format!("mod {};\n", sub_mod.replace(".rs", "")))
    }

    let file_path = path.as_ref().join("mod.rs");
    File::create(file_path)
        .into_diagnostic()?
        .write_all(contents.as_bytes())
        .into_diagnostic()
}

fn write_scope(path: impl AsRef<Path>, scope: &Scope) -> miette::Result<()> {
    let contents = format!("{}{}", FILE_HEADER, scope.to_string());

    let mut file = File::create(path).into_diagnostic()?;
    file.write_all(contents.as_bytes()).into_diagnostic()?;
    file.sync_all().into_diagnostic()
}
